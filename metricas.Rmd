---
title: "Métricas da paisagem"
author: "Darren Norris"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    toc: yes
    toc_depth: 3
    toc_float: yes
    fig_caption: yes
  bookdown::pdf_document2:
    toc: yes
    toc_depth: 3
    number_sections: yes
    extra_dependencies: flafter
    highlight: tango
    includes:
      in_header: preamble.txe
urlcolor: blue
toc-title: Sumário
header-includes:
  - \counterwithin{figure}{section}
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  echo = TRUE, collapse = TRUE,
  comment = "#>" 
  )
def_hook <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
  out <- def_hook(x, options)
  return(paste("\\begin{framed}\\begin{verbatim}", x, "\\end{verbatim}\\end{framed}", collapse = "\n"))
})
```

\newpage{}

# Apresentação
Nesta aula (...) vamos .... na ecologia da paisagem através cálculos com a proporção de floresta.
Durante a aula você aprenderá a

# Codigo e R
 * Objetivo não é de apresentar detalhes sobre os métodos ou os funções no [R](https://cran.r-project.org/). Existem diversos exemplos disponíveis [“Ciência de Dados com R–Introdução......”: ](https://cdr.ibpad.com.br/cdr-intro.pdf) e com google "r cran introdução tutorial".......
 
 geocomputation with R, see this excellent Gitbook: https://geocompr.robinlovelace.net/index.html.
com capitulo focado na ecologia: https://geocompr.robinlovelace.net/eco.html
landscapemetrics : https://bookdown.org/hhwagner1/LandGenCourse_book/WE_2.html

E exemplos com foco em genética das paisagems https://bookdown.org/hhwagner1/LandGenCourse_book/
 
 Alem disso, existem grupos de ajuda, como por exemplo: [R Brasil](https://www.facebook.com/groups/rbrasilprogramadores/)
 e 
[Stack Overflow em Português](https://pt.stackoverflow.com/questions/tagged/r)

 * O objetivo é  de apresentar um tutorial mostrado os capacidades e opções para desenvolver e integrar pesquisas de ecologia da paisagem no ambiente estatística de [R](https://cran.r-project.org/)

Porque use R? R tem a capacidade (baseada em codigo) para alternar  entre tarefas de processamento, modelagem e visualização de dados geográficos e não geográficos. Alem disso, como é possível importar, modificar, analisar e visualizar dados espaciais no mesmo ambiente com script/codigo, o R permite fluxos de trabalho transparentes e reproduzíveis ([A Ciência Aberta](https://foster.gitbook.io/manual-de-formacao-em-ciencia-aberta/02introducaoacienciaaberta/01conceito_e_principios_da_ciencia_aberta)).

Aliás, atualmente a grande maioria dos artigos científicos publicados na revista [Landscape Ecology](https://www.springer.com/journal/10980/) incluir análises usando R.

\newpage

## Organização do codigo no tutorial
O tutorial está organizado em etapas de processamento, com blocos de código em caixas cinzas:
```{r, eval=FALSE}
codigo de R para executar
```

Para segue os passos, os blocos de código precisam ser executados em sequência. Se você pular uma etapa, ou rodar fora de sequência o próximo bloco de código provavelmente não funcionará.

As linhas de codigo de R dentro de cada caixa tambem preciso ser executados em sequência. O simbolo `r kableExtra::text_spec("#", bold = TRUE)` é usado para incluir comentarios sobre os passos no codgio (ou seja, linhas começando com  `r kableExtra::text_spec("#", bold = TRUE)` não é codigo de executar).



```{r, eval=FALSE}
# Passo 1
codigo de R passo 1 # texto e numeros tem cores diferentes
# Passo 2
codigo de R passo 2
# Passo 3
codigo de R passo 3
```

Alem disso, os simbolos `r kableExtra::text_spec("#>", bold = TRUE)` e/ou `r kableExtra::text_spec("[1]", bold = TRUE)` no início de uma linha indica o resultado que você verá no console de R depois de rodar o codigo, como no proximo exemplo.


```{r, echo=TRUE, results='asis', evaluate = TRUE, collapse = TRUE}
# Passo 1
1+1

# Passo 2
x <- 1+1
# Passo 3
x

# Passo 4
x + 1

```

## Métricas da paisagem e pacote "landscapemetrics"

As métricas de paisagem são a forma que os ecólogos de paisagem usam para descrever os padrões espaciais de paisagens para depois avaliar a influência destes padrões espaciais nos padrões e processos ecológicos.
 

landscapemetrics é um pacote R para calcular métricas de paisagem em paisagems categóricos (onde tem uma classificação de cobertura de terra/habitat), em um fluxo de trabalho organizado. O pacote pode ser usado como um substituto do FRAGSTATS ([McGarigal et al. 1995](https://doi.org/10.2737/PNW-GTR-351) https://doi.org/10.2737/PNW-GTR-351), pois oferece um fluxo de trabalho reproduzível para análise de paisagem em um único ambiente. Também permite cálculos de quatro métricas teóricas de complexidade da paisagem:  entropia marginal, entropia condicional, entropia conjunta e informação mútua ([Nowosad e Stepinski 2019](https://doi.org/10.1007/s10980-019-00830-x) https://doi.org/10.1007/s10980-019-00830-x).

Nesse pacote o formato geral para uma função é o seguinte:
A primeira parte é sempre lsm_ ("landscapemetric"), seguinda do “nível_” e por fim a “métrica”. Ou seja, todas as funções começam com lsm_ , daí você deve incluir o nível da análise “p” para patch (ou seja, para a mancha ou fragmento), “c” para classe e “l” para landscape ou seja, para métricas para a paisagem como um todo. E daí existem inúmeras métricas, como por exemplo a <code>cpland</code> (percentual de área central - “core area”) na paisagem, como vimos na aula teórica. Digite o código abaixo e veja o resultado. Leia com atenção e preste particular atenção na organização da página de ajuda.

```{r, message=FALSE, echo=FALSE, eval=TRUE,  warning=FALSE}
library(landscapemetrics)
```

```{r, message=FALSE, eval=FALSE, warning=FALSE}
library(landscapemetrics)
?landscapemetrics
```

No final da página você vai encontrar a palavra "Index". Clique nela e você verá todas as funções do pacote. Desca até as lsm_. . . e clique em algumas delas ali. Explorar!

### Pergunta 1
`r kableExtra::text_spec("Descreva brevemente 2 métricas de cada nível.", color = "blue", bold = TRUE)`


--------------------------------------------------

## Pacotes

Além do "landscapemetrics", precisamos carregar alguns pacotes a mais para facilitar a organização e apresentação de dados espaciais (vector e raster) e os resultados.

Carregar pacotes (que deve esta instalado antes): 
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(terra)
library(tmap)
library(gridExtra)
library(kableExtra)
library(mgcv)
```


# Dados

Existem varios formas de importar e exportar dados geoespaciais, mais detalhes e exemplos : https://geocompr.robinlovelace.net/read-write.html .
Precisamos o arquivo com os dados de MapBiomas "amostra_mapbiomas_2020.tif", que voces baixaram no tutorial anterior (Escala https://rpubs.com/darren75/escala).
Nós podemos carregar os dados de cobertura da terra "amostra_mapbiomas_2020.tif" com a função <code>rast</code>.
```{r eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
# Selecionar e carregar arquivo "amostra_mapbiomas_2020.tif"
ramostra <- rast(file.choose())
# criar uma nova camada de floresta
floresta_2020 <- mapbiomas_2020
# Com valor de 0
values(floresta_2020) <- 0
# Atualizar categorias florestais agrupados com valor de 1
floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] <- 1 
```

```{r, echo=FALSE}
rin <- "data/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif"
mapbiomas_2020 <- rast(rin)
# criar uma nova camada de floresta
floresta_2020 <- mapbiomas_2020
# Com valor de 0
values(floresta_2020) <- 0
# Atualizar categorias florestais agrupados com valor de 1
floresta_2020[mapbiomas_2020==3 | mapbiomas_2020==4] <- 1 
```

Plotar para verificar, incluindo nomes e os cores para classes de floresta (valor = 1) e não-floresta (valor = 0).

```{r, eval = FALSE}
# Passo necessario para agilizar o processamento
floresta_2020_modal<-aggregate(floresta_2020, fact=10, fun="modal")
# Plot
tm_shape(floresta_2020_modal) +
  tm_raster(style = "cat", 
            palette = c("0" = "#E974ED", "1" ="#129912"), legend.show = FALSE) + 
  tm_add_legend(type = "fill", labels = c("não-floresta", "floresta"),
    col = c("#E974ED", "#129912"), title = "Classe") + 
tm_layout(legend.bg.color = "white")
```

Se esta todo certo, voces devem ter uma imagem parcida como o segunite:

```{r, echo = FALSE, fig.width=5, fig.height=5, fig.cap="Floresta ao redor do Rio Araguari. MapBiomas 2020 reclassificado em floresta e não-floresta."}
# Passo necessario para agilizar o processamento
floresta_2020_modal<-aggregate(floresta_2020, fact=10, fun="modal")
# Plot
tm_shape(floresta_2020_modal) +
  tm_raster(style = "cat", 
            palette = c("0" = "#E974ED", "1" ="#129912"), legend.show = FALSE) + 
  tm_add_legend(type = "fill", labels = c("não-floresta", "floresta"),
    col = c("#E974ED", "#129912"), title = "Classe") + 
tm_layout(legend.bg.color = "white")
```


Agora temos a paisagem, precisamos tambem os pontos de amostra. Por isso, precisamos carregar os dados de rios e pontos de amostragem que usamos no tutorial Escala - arquivo "rivers.GPKG". Vamos carregar as camadas que voces baixaram no tutorial anterior. Selecionando o arquivo "rivers.GPKG", e carregando primeiramente a camadas "midpoints" e depois "centerline".

No exemplo, usamos `r kableExtra::text_spec("%>%", bold = TRUE)`, que estabelece a ligação entre os passos do processo. Onde primeiramente carregamos os dados e em seguida converter as coordenadas para o mesmo sistema de referência que o arquivo raster (com a função st_transform). 

```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, results='hide'}
meuSIG <- "data/rivers.gpkg"
fs <- file.size(meuSIG)/(1024^2)
# pontos cada 5 km
rsm_31976 <- sf::st_read(meuSIG, layer = "midpoints") %>% 
  st_transform(31976) 
# linha central de rios
rsl_31976 <- sf::st_read(meuSIG, layer = "centerline") %>% 
  st_transform(31976) 
```


```{r, eval=FALSE, message=FALSE, results = FALSE}
#  Selecionar o arquivo "rivers.GPKG",
meuSIG <- file.choose()
# Carregar pontos cada 5 km, camada midpoints
rsm_31976 <- sf::st_read(meuSIG, layer = "midpoints") %>% 
  st_transform(31976) 
# Carregar linha central de rios, camada centerline
rsl_31976 <- sf::st_read(meuSIG, layer = "centerline") %>% 
  st_transform(31976) 
```

\newpage

Visualizer para verificar. 
```{r, eval=FALSE}
# Passo necessario para agilizar o processamento
floresta_2020_modal<-aggregate(floresta_2020, fact=10, fun="modal")
# Plot
tm_shape(floresta_2020_modal) +
  tm_raster(style = "cat", 
            palette = c("0" = "#E974ED", "1" ="#129912"), legend.show = FALSE) + 
  tm_add_legend(type = "fill", labels = c("não-floresta", "floresta"),
    col = c("#E974ED", "#129912"), title = "Classe") + 
tm_shape(rsl_31976) + 
  tm_lines(col="blue") + 
tm_shape(rsm_31976) + 
  tm_dots(size = 0.2, col = "yellow") + 
tm_layout(legend.bg.color="white")
```

Depois de executar ("run") o código acima, você deverá ver a figura a seguir.

```{r, echo=FALSE, fig.width=5, fig.height=5, fig.cap="Cobertura da terra ao redor do Rio Araguari em 2020. Mostrando os pontos de amostragem (pontos amarelas) cada 5 quilômetros ao longo do rio (linha azul)."}
# Passo necessario para agilizar o processamento
mapbiomas_2020_modal<-aggregate(mapbiomas_2020, fact=10, fun="modal")
# Plot
tm_shape(floresta_2020_modal) +
  tm_raster(style = "cat", 
            palette = c("0" = "#E974ED", "1" ="#129912"), legend.show = FALSE) + 
  tm_add_legend(type = "fill", labels = c("não-floresta", "floresta"),
    col = c("#E974ED", "#129912"), title = "Classe") + 
tm_shape(rsl_31976) + 
  tm_lines(col="blue") + 
tm_shape(rsm_31976) + 
  tm_dots(size = 0.2, col = "yellow") + 
tm_layout(legend.bg.color="white")
```

--------------------------------------------


\newpage


# Calculo de métricas
Para ilustrar como rodar as funções e cálculos com landscapemetrics, vamos calcular a área central na paisagem que usamos no tutorial de escala. Vamos estudar uma classe (floresta), portanto vamos incluir as métricas para nível de classe. Além disso, as métricas de paisagem em nível de classe são mais eficazes na definição de processos ecológicos (Tischendorf, L. Can landscape indices predict ecological processes consistently?. Landscape Ecology 16, 235–254 (2001). 
https://doi.org/10.1023/A:1011112719782.).

Para calcular as métricas de paisagem dentro de um certo buffer em torno de pontos de amostra, existe a função <code>sample_lsm()</code>. Através da função <code>sample_lsm()</code> podemos calcular mais de 50 métricas da paisagem, dentro de extensões diferentes.

Para a função <code>sample_lsm()</code> funcionar, precisamos informar 
(i) a paisagem (arquivo de raster), (ii) ponto (vector), 
(iii) raio, (iv) forma do buffer (círculo ou quadrado) e por final (v) a métrica  desejada.

##  Ponto único, raio único, métrica única

Métricas de área central ("core area") são consideradas medidas da qualidade de hábitat, uma vez que indica quanto existe realmente de área efetiva de um fragmento, após descontar-se o efeito de borda. Vamos calcular a percentual de área central ("core area") no entorno de um ponto de amostragem. Isso seria, a percentual de áreas centrais (excluídas as bordas de 30 m) de cada classe em relação à área total da paisagem.


```{r, echo=TRUE, message=FALSE, warning=FALSE}
minha_amostra_1000 <- sample_lsm(floresta_2020, y = rsm_31976[1, ], 
                            size = 1000, shape = "circle", 
                            metric = "cpland", 
                            edge_depth = 1) 
```

Depois que executar ("run"), podemos olhar os dados com o codigo a seguir. 
```{r, eval=FALSE}
minha_amostra_1000
```

Os dados deve ter os valores:
```{r, echo=FALSE, message=FALSE, warning=FALSE}
minha_amostra_1000 %>% 
  kbl() %>%
  kable_styling(full_width = F,  latex_options = "hold_position")
```

### Pergunta 2

`r kableExtra::text_spec("O modelo mancha-corredor-matriz é frequentemente adotado na ecologia da paisagem. Com base nas aulas teóricas e usando os valores no objeto minha_amostra_1000 apresentados na tabela acima, identificar qual classe representar a matriz na paisagem. Há alguma informação faltando que limita a sua capacidade de identificar qual classe representar a matriz? Se sim, o que precisa ser adicionado? Justifique as suas respostas de forma clara e concisa.", color = "blue", bold = TRUE)`

----------------------------------------------------------------


\newpage

## Ponto único, distâncias variados, métrica única

```{r, echo=FALSE, message=FALSE, out.width="90%", out.height="90%",fig.cap="Cobertura florestal em extensões diferentes ao redor de um ponto de amostragem."}
# 1000 m
rsm_31976_b1000 <- st_buffer(rsm_31976[1, ], dist = 1000)
# 2000 m
rsm_31976_b2000 <- st_buffer(rsm_31976[1, ], dist = 2000)
# 4000 m
rsm_31976_b4000 <- st_buffer(rsm_31976[1, ], dist = 4000)
# 8000 m
rsm_31976_b8000 <- st_buffer(rsm_31976[1, ], dist = 8000)
# 16000 m
rsm_31976_b16000 <- st_buffer(rsm_31976[1, ], dist = 16000)
buffer.forest1.16000m <- crop(floresta_2020, rsm_31976_b16000)
buffer.forest1.16000m <- mask(buffer.forest1.16000m, rsm_31976_b16000)

#fig all together
line_col <- "black"
fig_together <- tm_shape(buffer.forest1.16000m) +
  tm_raster(style = "cat", 
            palette = c("0" = "#E974ED", 
                        "1" ="#129912"), legend.show = FALSE) + 
  tm_shape(rsm_31976[1, ]) + 
    tm_symbols(shape =21, col = "yellow", 
            border.col = "black", border.lwd = 0.2, size=0.5) + 
  tm_shape(rsm_31976_b1000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b2000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b4000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b8000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b16000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_add_legend(type = "fill", 
    labels = c("não-floresta", "floresta"),
    col = c("#E974ED", "#129912"),
    title = "Classe") + 
tm_scale_bar(breaks = c(0, 2, 4), text.size = 1, 
             position=c("left", "bottom")) +
tm_layout(legend.position = c("right","top"),
          legend.bg.color = "white")
fig_together
```


Para uma comparação multiescala, vamos calcular a mesma métrica, no mesmo ponto, mas agora com extensões diferentes. Continuando o exemplo no tutorial anteriio (Escala), vamos repetir o mesmo processo, mas agora com raios de 250, 500, 1000, 2000, 4000, 8000 e 16000 metros, doubrando a escala (extensão) em cada passo. 

\newpage

Para obter resultados com extensões diferentes, precisamos primeiramente repetir o código, ajustando para cada extensão, e depois juntar os resultados. 
O código a seguir calculará a mesma métrica para as diferentes distâncias.
No exemplo, usamos `r kableExtra::text_spec("%>%", bold = TRUE)`, que estabelece a ligação entre os passos do processo. Neste caso, para incluir uma coluna nova (raio) para manter o valor das diferentes distâncias.
```{r, echo=TRUE, message=FALSE, warning=FALSE}
# raio 250 metros
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 250, shape = "circle", 
           metric = "cpland") %>% 
  mutate(raio = 250) -> minha_amostra_250 
# raio 500 metros
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 500, shape = "circle", 
           metric = "cpland")  %>% 
  mutate(raio = 500) -> minha_amostra_500
# raio 1 km (1000 metros)
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 1000, shape = "circle", 
           metric = "cpland")  %>% 
  mutate(raio = 1000) -> minha_amostra_1000
# raio 2 km
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 2000, shape = "circle", 
           metric = "cpland") %>% 
  mutate(raio = 2000) -> minha_amostra_2000
# raio 4 km
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 4000, shape = "circle", 
           metric = "cpland")  %>% 
  mutate(raio = 4000) -> minha_amostra_4000
# raio 8 km
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 8000, shape = "circle", 
           metric = "cpland")  %>% 
  mutate(raio = 8000) -> minha_amostra_8000
# raio 16 km
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 16000, shape = "circle", 
           metric = "cpland")  %>% 
  mutate(raio = 16000) -> minha_amostra_16000
```

\newpage

E agora, o código a seguir juntará os resultados das diferentes extensões.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
bind_rows(minha_amostra_250, 
          minha_amostra_500, 
          minha_amostra_1000, 
          minha_amostra_2000, 
          minha_amostra_4000, 
          minha_amostra_8000, 
          minha_amostra_16000) -> amostras_metrica

```


Depois que executar ("run"), podemos olhar os dados "amostras_metrica" com o codigo a seguir. 
```{r, eval=FALSE}
amostras_metrica
```

Os dados deve ter os valores (coluna value) da métrica (coluna metric) de cada classe (coluna class) para cada distância (coluna raio):
```{r, echo=FALSE, message=FALSE, warning=FALSE}
amostras_metrica %>% 
  mutate_if(is.numeric, format, digits=1,nsmall = 0) %>%
  kbl() %>%
  kable_styling(full_width = F,  latex_options = "hold_position")
```

\newpage


### Faça um gráfico

Uma imagem vale mais que mil palavras. Portanto, gráficos/figuras/imagens são uma das mais importantes formas de comunicar a ciência. Os dados apresentados em uma tabela podem ser difíceis de entender. Portanto, a primeira pergunta que você deve se fazer é se você pode transformar aquela tabela (chata e feia) em algum tipo de gráfico. Lembrando, sempre pode incluir a tabela como anexo. 

Aqui, vamos fazer um grafico com os dados amostras_metrica,
usando o pacote ggplot2.

O ggplot2 faz parte do conjunto "tidyverse", e é um pacote de visualização de dados. "gg" se refere a uma gramática de gráficos. A ideia principal é criar um gráfico como se fosse uma frase de uma língua, onde cada elemento do gráfico seria uma palavra, organizados em uma sequencia logica para construir uma frase completo (gráfico final). Isto nos permite construir gráficos tão complexos quanto quisermos. Os gráficos criados com ggplot2 são, em geral, mais elegantes do que os gráficos tradicionais do R.

O ggplot2 exige que os dados a serem plotados estejam em um data frame. Ou seja, sempre teremos que transformar os dados para data frame ou construir um data frame com os dados que possuímos.

O comando principal função a ser utilizado se chama ggplot.

Para ggplot, precisamos os dados (data frame), e depois cria o “mapeamento” das variáveis, normalmente usando "aes" (de aesthetics). Ou seja, você especifica quais são as variáveis dos eixos x e y dentro de aes. Através dele vamos definir qual é a variável preditora/explanatora (eixo x) e qual é a variável resposta (eixo y) em nosso conjunto de dados. 

Depois da função ggplot, na sequencia no codigo nós especificamos qual tipo de grafico com um "geom". Por exemplo, geom_point para plotar pontos, geom_boxplot para um boxplot, etc. Para a lista completa de geoms e todas as outras opções do pacote, visite a página do projeto ggplot2, 
livro e sempre exemplos no google, por exemplo digitando: ggplot2 grafico de barra no Google, tem mais de 50 mil resultados com  paginas de imagens, codigo pronto e exemplos no YouTube.

Note que adicionamos um geom com um “+”. No ggplot2, nós criamos gráficos em camadas, e adicionamos camada a camada com um “+”. assim, é posivel ajustar qualquer elemento do grafico.

Aqui vamos fazer um gráfico com valores de extensão no eixo x e proporção da floresta central no eixo y.
Assim sendo, com o codigo a segir, vamos informar (i) os dados, selecionando classe de floresta atraves de um filtro e acresentando uma coluna nova ("ext_m") com a extensão em metros, (ii) as colunas para os eixos x e y, (iii) tipo de grafico (grafico de pontos - geom_point() ), (iv) nomes para os eixos. No exemplo, usamos `r kableExtra::text_spec("%>%", bold = TRUE)`, que estabelece a ligação entre os passos do processo.
```{r, eval=FALSE}
# arrumar os dados
amostras_metrica %>% 
  filter(class==1) %>% 
  mutate(ext_m = 2*raio) %>%
# fazer o grafico
  ggplot(aes(x=ext_m, y=value)) + 
  geom_point() + 
  labs(x = "Extensão (metros)", 
       y = "Área central de floresta (porcentagem da paisagem)")
```

Depois de executar (“run”) o código acima, você deverá ver o grafico a seguir.

```{r, echo=FALSE, out.width="60%", out.height="60%"}
amostras_metrica %>% 
  filter(class==1) %>%
  mutate(ext_m = 2*raio) %>%
  ggplot(aes(x=ext_m, y=value)) + 
  geom_point() + 
  labs(x = "Extensão (metros)", 
       y = "Área central de floresta (porcentagem da paisagem)")
```


### Pergunta 3

`r kableExtra::text_spec("Em vez de extensão, você preciso incluir o tamanho (área) correspondente a cada raio. Incluir uma cópia do código ajustado para produzir uma figura com tamanho (área em quilômetros quadrados) no eixo x e a percentual de área central de floresta no eixo y.", color = "blue", bold = TRUE)`

--------------------------------------------

### Faça um gráfico elegante

Podemos ajustar qualquer elemento do grafico. Agora, vamos mudar as unidades de metros para quilometros, aumentar o tamanho dos pontos, incluir uma linha reta para ilustrar a tendência geral, colocar o titulo longo do eixo y em duas linhas, e aumentar o tamanho da fonte para o texto ficar mais claro. 
```{r, out.width="60%", out.height="60%", fig.cap="Comparação da área central de floresta em diferentes extensões." }
amostras_metrica %>% 
  filter(class==1) %>% 
  mutate(ext_m = 2*raio, 
         ext_km = (2*raio)/1000) %>%
  ggplot(aes(x=ext_km, y=value)) + 
  geom_point(size = 4) + 
  stat_smooth(method = "lm", se = FALSE, color = "green") + 
  labs(x = "Extensão (quilômetros)", 
       y = "Área central de floresta\n(porcentagem da paisagem)") + 
  theme(text = element_text(size = 18)) 
```

### Pergunta 4

`r kableExtra::text_spec("Em menos de 200 palavras apresente a sua interpretação do gráfico em figura 4.2.", color = "blue", bold = TRUE)`

-----------------------------------------


\newpage

### Compare linear and non linear
```{r create-fig-comp, echo=FALSE, message=FALSE, warning=FALSE}
amostras_metrica %>% 
  filter(class==1) %>%
  ggplot(aes(x=(2*raio)/1000, y=value)) + 
  geom_point() + 
  stat_smooth(method = "lm", color = "green") + 
  coord_cartesian(ylim = c(0,100)) +
  labs(title = "Modelo linear", 
       x = "Extensão (quilômetros)", 
       y = "Área central de floresta\n(porcentagem da paisagem)") -> fig_lm

amostras_metrica %>% 
  filter(class==1) %>%
  ggplot(aes(x=(2*raio)/1000, y=value)) + 
  geom_point() + 
  stat_smooth(method = "gam", formula = y ~ s(x, k = 5)) + 
  coord_cartesian(ylim = c(0,100)) +
  labs(title = "Modelo não-linear", 
       x = "Extensão (quilômetros)", 
       y = "Área central de floresta\n(porcentagem da paisagem)") -> fig_gam

pdf("figures/fig_comp_linear.pdf", width=7, height=3)
grid.arrange(fig_lm, fig_gam, nrow=1)
invisible(dev.off())

png("figures/fig_comp_linear.png", width=7, height=3, 
    units="in", res = 600)
grid.arrange(fig_lm, fig_gam, nrow=1)
invisible(dev.off())

```

include figure

more text

```{r insert-fig-comp, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Comparação de padrões lineares e não-lineares."}
knitr::include_graphics("figures/fig_comp_linear.png")
```



### Pergunta 5
`r kableExtra::text_spec("Comparar os resultados apresentados nas figuras com modelos lineares e não-lineares. Qual modelo seria mais adequado para identificar limiares no padrão de área central de floresta?", color = "blue", bold = TRUE)`

-------

\newpage

## Ponto único, distâncias variados, métricas variadas

Como as mudanças na estrutura da paisagem caracterizam-se por serem não-lineares, para desenvolver análises estatísticas robustos pode (i) aplicar uma transformação (por exemplo, "log") ou (ii) adotar modelos não-lineares. Aqui, usaremos modelos não lineares para comparar padrões em diferentes métricas da paisagem  em diferentes extensões.


```{r insert-fig-buffmetrics, fig.cap="Ilustração da determinação de métricas da paisagem diferentes ao redor de um ponto. Exemplo com a estrutura da paisagem representado com trés caracteristicas (A) Área central, (B) Borda e (C) Vizinho mais próximo. O habitat de interesse (classe) é isolado. Um buffer (linha tracejada) é colocado ao redor de um ponto (amarela) e as métricas calculadas. E em seguida o processo é repetido em diferentes extensões.", echo=FALSE, warning=FALSE, message=FALSE}
ragg <- aggregate(buffer.forest1.16000m, fact=5, fun="median")
ragg_forest <- ragg
# Com valor de NA
values(ragg_forest) <- NA
# Atualizar categorias florestais agrupados com valor de 1
ragg_forest[ragg==1] <- 1 

#ragg10 <- aggregate(buffer.forest1.16000m, fact=10, fun="median")

my_metric_r_all = spatialize_lsm(ragg_forest, level = "patch", metric = "enn")
r_enn <- my_metric_r_all$layer_1$lsm_p_enn

fig_enn <- tm_shape(r_enn) +
  tm_raster(title = "distância", n=9, palette = "-viridis") + 
tm_shape(rsm_31976[1, ]) + 
    tm_symbols(shape =21, col = "yellow", 
            border.col = "black", border.lwd = 0.2, size=0.5) + 
tm_shape(rsm_31976_b1000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
tm_shape(rsm_31976_b2000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
tm_shape(rsm_31976_b4000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
tm_shape(rsm_31976_b8000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
tm_shape(rsm_31976_b16000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
tm_scale_bar(breaks = c(0, 2, 4), text.size = 1, 
             position=c("left", "bottom")) + 
tm_layout(main.title = "(C) Vizinho mais próximo", main.title.size = 1)

classpoly <- as.polygons(ragg)
# https://gis.stackexchange.com/questions/392505/can-i-use-r-to-do-a-buffer-inside-polygons-shrink-polygons-negative-buffer/392525
shrinkIfPossible <- function(sf, size) {
  # compute inward buffer
  sg <- st_buffer(st_geometry(sf), -size)
  
  # update geometry only if polygon is not degenerate
  st_geometry(sf)[!st_is_empty(sg)] = sg[!st_is_empty(sg)]
   
  # return updated dataset
  return(sf)
}
classpoly_sf <- st_as_sf(classpoly)
SelForest <- which(classpoly_sf$classification_2020==1)
shp_buffered <- shrinkIfPossible(classpoly_sf[SelForest, ], 300)

fig_core <- tm_shape(buffer.forest1.16000m) +
  tm_raster(style = "cat", 
            palette = c("0" = "#E974ED", 
                        "1" ="#129912"), legend.show = FALSE) + 
  tm_shape(shp_buffered) + 
   tm_fill("lightgreen") + 
   tm_shape(rsm_31976[1, ]) + 
    tm_symbols(shape =21, col = "yellow", 
            border.col = "black", border.lwd = 0.2, size=0.5) + 
  tm_shape(rsm_31976_b1000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b2000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b4000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b8000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b16000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
tm_add_legend(type = "fill", 
    labels = c("não-floresta", "floresta", "área central"),
    col = c("#E974ED", "#129912", "lightgreen")) + 
tm_scale_bar(breaks = c(0, 2, 4), text.size = 1, 
             position=c("left", "bottom")) +
  tm_layout(legend.position = c("right","top"),
          legend.bg.color = "white") + 
tm_layout(main.title = "(A) Área central", main.title.size = 1)

fig_edge <- tm_shape(buffer.forest1.16000m) +
  tm_raster(style = "cat", 
            palette = c("0" = "#E974ED", 
                        "1" ="lightgray"), legend.show = FALSE) + 
  tm_shape(shp_buffered) + 
   tm_fill("#129912") + 
   tm_shape(rsm_31976[1, ]) + 
    tm_symbols(shape =21, col = "yellow", 
            border.col = "black", border.lwd = 0.2, size=0.5) + 
  tm_shape(rsm_31976_b1000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b2000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b4000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b8000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
  tm_shape(rsm_31976_b16000) +
    tm_borders(col = line_col, lwd = 4, lty = "dashed") + 
tm_add_legend(type = "fill", 
    labels = c("não-floresta", "floresta", "borda"),
    col = c("#E974ED", "#129912", "lightgray")) + 
tm_scale_bar(breaks = c(0, 2, 4), text.size = 1, 
             position=c("left", "bottom")) +
  tm_layout(legend.position = c("right","top"),
          legend.bg.color = "white") + 
tm_layout(main.title = "(B) Borda", main.title.size = 1)

tmap_arrange(fig_core, fig_edge, fig_enn, nrow=1)

```

include text 



more here

Plot extensions nclude figure

more text



see what happens

-------



Multiplwe metricas area for all exten...
<code>sample_lsm()</code>

Aqui vamos .........

 * Métricas de área e borda. Quantificam a composição da paisagem e fornecem sobre ela informações importantes sobre a dinâmica de populações vegetais e animais  
    *  <code>pland</code> = area and edge metric / percentage of landscape percentagem da paisagem Porcentagem de cobertura da classe na paisagem.  
    * <code>ed</code> = area and edge metric / edge density . densidade de borda que é igual à soma dos comprimentos (m) de todos os segmentos de borda que envolvem o fragmento, dividida pela área total da paisagem (m²), sendo posteriormente convertido em hectares.
    * <code>cpland</code> = core area metric / core area percentage of landscape / (percentual de área central ("core") na paisagem) Percentual de áreas centrais (excluídas as bordas de 30 m) em relação à área total da paisagem. O termo "Core area" foi traduzido como área central ou área núcleo. Aqui vamos adotar área central.

 * Métricas de agregação. Quantificam a configuração da paisagem:
    * <code>enn</code> = aggegation metric / euclidian nearest neighbour distance distância euclidiana do vizinho mais próximo. 
    * <code>enn_cv</code> = aggegation metric. Coeficiente de variação da distância euclidiana do vizinho mais próximo. A métrica resume cada classe como o Coeficiente de variação das distâncias euclidianas do vizinho mais próximo entre as manchas pertencentes à classe. O valor de enn_cv = 0 se a distância euclidiana do vizinho mais próximo for idêntica para todas as manchas. Aumenta, sem limite, à medida que a variação do ENN aumenta.
    * <code>enn_sd</code> = aggegation metric.
    * <code>pd</code> = aggegation metric / patch density densidade das manchas
    * <code>cohesion</code> = aggregation metric / índice de coesão das manchas.
    


```{r, echo=TRUE, message=FALSE, warning=FALSE}
# Objeto com os nomes das funções para calcular as métricas desejadas.
minhas_metricas <- c("lsm_c_pland", "lsm_c_ed", "lsm_c_cpland", "lsm_c_enn_mn", "lsm_c_enn_sd", "lsm_c_enn_cv", "lsm_c_pd","lsm_c_cohesion")
metricas_composicao <- c("pland", "ed", "cpland")

# Métricas calculadas para cada extensão
# raio 250 metros
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 250, shape = "circle", 
           what = minhas_metricas) %>% 
  mutate(raio = 250, 
         met_cat = if_else(metric %in% metricas_composicao, 
                           "composição", "configuração")) -> metricas_amostra_250 
# raio 500 metros
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 500, shape = "circle", 
           what = minhas_metricas)  %>% 
   mutate(raio = 500, 
         met_cat = if_else(metric %in% metricas_composicao, 
                           "composição", "configuração")) -> metricas_amostra_500
# raio 1 km (1000 metros)
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 1000, shape = "circle", 
           what = minhas_metricas)  %>% 
   mutate(raio = 1000, 
         met_cat = if_else(metric %in% metricas_composicao, 
                           "composição", "configuração")) -> metricas_amostra_1000
# raio 2 km (2000 metros)
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 2000, shape = "circle", 
           what = minhas_metricas) %>% 
  mutate(raio = 2000, 
         met_cat = if_else(metric %in% metricas_composicao, 
                           "composição", "configuração")) -> metricas_amostra_2000
# raio 4 km (4000 metros)
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 4000, shape = "circle", 
           what = minhas_metricas)  %>% 
  mutate(raio = 4000, 
         met_cat = if_else(metric %in% metricas_composicao, 
                           "composição", "configuração"))  -> metricas_amostra_4000
# raio 8 km (8000 metros)
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 8000, shape = "circle", 
           what = minhas_metricas)  %>% 
  mutate(raio = 8000, 
         met_cat = if_else(metric %in% metricas_composicao, 
                           "composição", "configuração")) -> metricas_amostra_8000
# raio 16 km (16000 metros)
sample_lsm(floresta_2020, y = rsm_31976[1, ], 
           size = 16000, shape = "circle", 
           what = minhas_metricas)  %>% 
  mutate(raio = 16000, 
         met_cat = if_else(metric %in% metricas_composicao, 
                           "composição", "configuração")) -> metricas_amostra_16000
```

join

```{r, echo=TRUE, message=FALSE, warning=FALSE}
bind_rows(metricas_amostra_250, 
          metricas_amostra_500, 
          metricas_amostra_1000, 
          metricas_amostra_2000, 
          metricas_amostra_4000, 
          metricas_amostra_8000, 
          metricas_amostra_16000) -> amostras_metricas

```

get forest 
```{r, echo=TRUE, message=FALSE, warning=FALSE}
amostras_metricas %>% 
  filter(class==1) -> amostras_metricas_floresta

```

Best to include forest metrics 250 as 0 or NA?

Plot

```{r insert-fig-multiplemetrics}
amostras_metricas_floresta %>% 
  mutate(ext_km = (2*raio)/1000) %>%
  ggplot(aes(x=ext_km, y=value)) + 
  geom_point() + 
  #stat_smooth(method = "gam", formula = y ~ s(x, k = 6), 
  #             se=FALSE) + 
  stat_smooth(method = "loess", se=FALSE) + 
  facet_wrap(met_cat~metric, scales = "free_y") +
  labs(title = "Multiple metris",
    x = "extensão (quilômetros)", 
    y = "metric value")
```

### Pergunta 

`r kableExtra::text_spec("Usando como base o conteudo das aulas, leitura disponivel no Google Classroom (Base teórica 4 Dados, métricas, analises), e/ou exemplos apresentados aqui no tutorial, selecione seis métricas de nível classe para caracterizar a paisagem de estudo e objectivos da sua projeto. Justifique sua seleção de forma clara e concisa, apoie sua escolha com exemplos da literatura científica.", color = "blue", bold = TRUE)`

----------------------------------------------------------